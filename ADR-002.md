# ADR-002: Estrutura da Aplicação Spring Boot para o NanoLink

*   **Status:** Proposto
*   **Data:** 2026-01-08
*   **Agente:** @Architect

## Contexto
Com a stack de tecnologia definida no ADR-001, é necessário estabelecer uma arquitetura de software clara e escalável para o backend do NanoLink. A estrutura deve promover a separação de responsabilidades (Separation of Concerns), facilitar a manutenção e permitir a evolução do projeto.

## Decisão
Adotaremos uma arquitetura em camadas (Layered Architecture) clássica para a aplicação Spring Boot, com a seguinte estrutura de pacotes e componentes:

### 1. Estrutura de Pacotes
A estrutura de pacotes será organizada por funcionalidade para agrupar classes relacionadas:
```
com.nanolink.backend
├── model/           // Entidades JPA (Data Classes)
├── repository/      // Spring Data JPA Repositories (Data Access)
├── service/         // Lógica de Negócio (Services)
├── controller/      // API Endpoints (Request Routing)
├── dto/             // Data Transfer Objects
└── exception/       // Exceções customizadas
```

### 2. Camada de Modelo (Data Classes)
*   **`UrlMapping.java`**: Entidade JPA que representa um mapeamento de URL.
    *   `id` (Long): Chave primária.
    *   `originalUrl` (String): A URL original e longa.
    *   `shortCode` (String): O código curto gerado. Deve ser único.
    *   `creationDate` (LocalDateTime): Data de criação do mapeamento.

### 3. Camada de Acesso a Dados (Repositories)
*   **`UrlMappingRepository.java`**: Interface que estende `JpaRepository<UrlMapping, Long>`.
    *   O Spring Data JPA implementará automaticamente os métodos CRUD básicos.
    *   Incluirá um método de busca customizado: `Optional<UrlMapping> findByShortCode(String shortCode);`

### 4. Camada de Serviço (Business Logic)
*   **`UrlShorteningService.java`**: Interface com os contratos da lógica de negócio.
*   **`UrlShorteningServiceImpl.java`**: Implementação da interface.
    *   **`createShortUrl(String originalUrl)`**:
        1.  Valida a URL original.
        2.  Gera um `shortCode` único e aleatório (ex: 6-8 caracteres alfanuméricos).
        3.  Verifica se o código já não existe no banco de dados. Se sim, gera um novo.
        4.  Salva a nova entidade `UrlMapping` no banco de dados através do `UrlMappingRepository`.
        5.  Retorna o `shortCode` gerado.
    *   **`getOriginalUrl(String shortCode)`**:
        1.  Busca o `UrlMapping` pelo `shortCode` no repositório.
        2.  Se não encontrar, lança uma exceção (ex: `ShortCodeNotFoundException`).
        3.  Se encontrar, retorna a `originalUrl`.

### 5. Camada de Controle (Request Routing)
*   **`UrlShortenerController.java`**: Controlador REST para manipular as requisições HTTP.
    *   **`POST /api/v1/shorten`**:
        *   Recebe um `ShortenUrlRequest` DTO contendo a `originalUrl`.
        *   Chama o `UrlShorteningService` para criar o código curto.
        *   Retorna um `ShortenUrlResponse` DTO com a URL encurtada completa (ex: `http://localhost:8080/aB1cD2eF`).
    *   **`GET /{shortCode}`**:
        *   Recebe o `shortCode` como uma variável de path (`@PathVariable`).
        *   Chama o `UrlShorteningService` para obter a URL original.
        *   Redireciona o usuário para a `originalUrl` com um status HTTP 302 (Found).

### 6. DTOs (Data Transfer Objects)
*   **`ShortenUrlRequest.java`**: Recebe a URL a ser encurtada (`private String url;`).
*   **`ShortenUrlResponse.java`**: Retorna a URL já encurtada (`private String shortUrl;`).

## Consequências
### Vantagens
*   **Organização e Clareza:** A separação em camadas torna o código mais fácil de entender e manter.
*   **Testabilidade:** Cada camada pode ser testada de forma isolada (unitariamente).
*   **Desacoplamento:** O uso de DTOs desacopla a representação da API da estrutura do banco de dados, adicionando uma camada de segurança e flexibilidade.
*   **Escalabilidade:** A estrutura modular permite que novas funcionalidades sejam adicionadas de forma consistente.

### Desvantagens
*   **Overhead para Projetos Simples:** Para uma aplicação extremamente simples, essa estrutura pode parecer excessiva, mas ela se paga à medida que o projeto cresce.

> *Generated by Gemini CLI*
